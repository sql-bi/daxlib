function 'DaxLib.FormatString.RelativeToTarget.Percents' = ```

		// Dynamic format string generator for comparison values (in percent)
		// Returns format string with directional indicators based on parameters
		(
		    // Position of comparison symbol
		    // Expects "PREFIX" or "SUFFIX"
		    position: STRING,

		    // Number of decimal places
		    // Expects an INT64 value from 0-9
		    decimal_places: INT64,

		    // Symbol style - number (1-9) or text:
		    // 1 or "ARROWS": ‚Üë/‚Üì
		    // 2 or "TRIANGLES": ‚ñ≤/‚ñº
		    // 3 or "PLUSMINUS": +/-
		    // 4 or "CHEVRONS": ÀÑ/ÀÖ
		    // 5 or "GREENRED": üü¢/üî¥
		    // 6 or "BLUEORANGE": üîµ/üü†
		    // 7 or "BLOCKARROWS": ‚¨Ü/‚¨á
		    // 8 or "CHECKCROSS": ‚úì/‚úó
		    // 9 or "NONE": no symbol
		    symbol: ANYVAL,

		    // Custom prefix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_prefix: EXPR,

		    // Custom suffix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    // Enter " (" & FORMAT ( [PercentMeasure], "0.0%" ) & ")" to add a second value for context
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_suffix: EXPR
		)
		=>
		    VAR _BaseFormat =
		        FormatString.Component.DecimalPlaces( "#,##0", decimal_places ) & "%"

		    VAR _Prefix =
		        FormatString.Component.MakeStringSafe ( custom_prefix )

		    VAR _Suffix =
		        FormatString.Component.MakeStringSafe ( custom_suffix )

		    VAR _PositiveSymbol =
		        FormatString.Component.Symbols ( symbol, "POSITIVE" )

		    VAR _NegativeSymbol =
		        FormatString.Component.Symbols ( symbol, "NEGATIVE" )

		    VAR _PositiveFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX", _PositiveSymbol & " " & _BaseFormat,
		                "SUFFIX", _BaseFormat & " " & _PositiveSymbol,
		                _BaseFormat & " " & _PositiveSymbol
		            )
		            &
		        _Suffix

		    VAR _NegativeFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX", _NegativeSymbol & " " & _BaseFormat,
		                "SUFFIX", _BaseFormat & " " & _NegativeSymbol,
		                _BaseFormat & " " & _NegativeSymbol
		            )
		            &
		        _Suffix

		    VAR _ZeroFormat =
		        _Prefix
		            &
		            _BaseFormat
		            &
		        _Suffix

		    RETURN
		        _PositiveFormat & ";" & _NegativeFormat & ";" & _ZeroFormat
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.RelativeToTarget.Numeric' = ```

		// Dynamic format string generator for comparison values (in value)
		// Returns format string with directional indicators based on parameters
		(
		    // Position of comparison symbol
		    // Expects "PREFIX" or "SUFFIX"
		    position: STRING,

		    // Number of decimal places
		    // Expects an INT64 value from 0-9
		    decimal_places: INT64,

		    // Symbol style - number (1-9) or text:
		    // 1 or "ARROWS": ‚Üë/‚Üì
		    // 2 or "TRIANGLES": ‚ñ≤/‚ñº
		    // 3 or "PLUSMINUS": +/-
		    // 4 or "CHEVRONS": ÀÑ/ÀÖ
		    // 5 or "GREENRED": üü¢/üî¥
		    // 6 or "BLUEORANGE": üîµ/üü†
		    // 7 or "BLOCKARROWS": ‚¨Ü/‚¨á
		    // 8 or "CHECKCROSS": ‚úì/‚úó
		    // 9 or "NONE": no symbol
		    symbol: ANYVAL,

		    // Custom prefix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_prefix: EXPR,

		    // Custom suffix text (optional)
		    // Enter "" to skip parameter
		    // Enter SELECTEDVALUE( 'Exchange Rate'[Currency Symbol] ) for dynamic currency conversion
		    // Enter " (" & FORMAT ( [PercentMeasure], "0.0%" ) & ")" to add a second value for context
		    //
		    // Note: Value is string-safe; no need for """"
		    custom_suffix: EXPR
		) =>
		    VAR _BaseFormat =
		        FormatString.Component.DecimalPlaces( "#,##0", decimal_places ) & "%"

		    VAR _Prefix =
		        FormatString.Component.MakeStringSafe ( custom_prefix )

		    VAR _Suffix =
		        FormatString.Component.MakeStringSafe ( custom_suffix )

		    VAR _PositiveSymbol =
		        FormatString.Component.Symbols ( symbol, "POSITIVE" )

		    VAR _NegativeSymbol =
		        FormatString.Component.Symbols ( symbol, "NEGATIVE" )

		    VAR _PositiveFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX",
		                    _PositiveSymbol & " " & _BaseFormat,
		                "SUFFIX",
		                    _BaseFormat & " " & _PositiveSymbol,
		                _BaseFormat & " " & _PositiveSymbol
		            )
		            & _Suffix

		    VAR _NegativeFormat =
		        _Prefix
		            & SWITCH (
		                position,
		                "PREFIX",
		                    _NegativeSymbol & " " & _BaseFormat,
		                "SUFFIX",
		                    _BaseFormat & " " & _NegativeSymbol,
		                _BaseFormat & " " & _NegativeSymbol
		            )
		            & _Suffix

		    VAR _ZeroFormat =
		        _Prefix & _BaseFormat & _Suffix

		    RETURN
		        _PositiveFormat & ";" & _NegativeFormat
		            & ";"
		            & _ZeroFormat
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.HHMMSS.StartTimeEndTime' = ```

		// Convert duration between start and end times to HH:MM:SS format string
		(
		    // Start datetime
		    // Include measure, expression, or scalar value
		    startTime: EXPR,

		    // End datetime
		    // Include measure, expression, or scalar value
		    endTime: EXPR
		) =>
		    VAR _DurationInSeconds =
		        INT( ( endTime - startTime ) * 86400 )

		    VAR _Hours =
		        INT( _DurationInSeconds / 3600 )

		    VAR _Minutes =
		        INT( MOD( _DurationInSeconds, 3600 ) / 60 )

		    VAR _Seconds =
		        INT( MOD( _DurationInSeconds, 60 ) )

		    VAR _Result =
		        FORMAT( _Hours, "00" ) & ":" &
		        FORMAT( _Minutes, "00" ) & ":" &
		        FORMAT( _Seconds, "00" )

		    RETURN
		        _Result
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.HHMMSS.Seconds' = ```

		// Convert duration in seconds to HH:MM:SS format string
		(
		    // Duration in seconds
		    seconds: NUMERIC
		) =>
		    VAR _TotalSeconds = seconds

		    VAR _Hours =
		        INT( _TotalSeconds / 3600 )

		    VAR _Minutes =
		        INT( MOD( _TotalSeconds, 3600 ) / 60 )

		    VAR _Seconds =
		        INT( MOD( _TotalSeconds, 60 ) )

		    VAR _Result =
		        FORMAT( _Hours, "00" ) & ":" &
		        FORMAT( _Minutes, "00" ) & ":" &
		        FORMAT( _Seconds, "00" )

		    RETURN
		        _Result
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.DynamicUnits' = ```

		// Dynamic format string with automatic K/M/bn/tn suffix, rounding, and decimal places based on value magnitude
		// Supports dynamic currency conversion
		(
		    // The value to format
		    // Expects a numeric value or measure reference
		    // Recommended: SELECTEDMEASURE()
		    format_value: EXPR,

		    // The currency symbol you want to use
		    // Expects a symbol like "$"
		    // Enter "" for none
		    // Use FormatString.Component.GetCurrencySymbol for dynamic currency conversion
		    currency_symbol: STRING,

		    // Whether the currency should be a prefix or suffix
		    // Expects "PREFIX" or "SUFFIX"
		    // Enter "" for none
		    // Use FormatString.Component.GetCurrencyPosition for dynamic currency conversion
		    currency_position: STRING,

		    // Custom prefix (optional)
		    // Enter "" for none
		    // Note: Value is string-safe; no need for """"
		    custom_prefix : EXPR,

		    // Custom suffix (optional)
		    // Enter "" for none
		    // Note: Value is string-safe; no need for """"
		    custom_suffix : EXPR
		)
		=>
		    VAR _NumberFormat =
		        FormatString.Component.DynamicUnits( "#,##0", format_value )

		    VAR _CurrencySymbol =
		        currency_symbol

		    VAR _CurrencyPosition =
		        currency_position

		    VAR _Prefix =
		        IF ( _CurrencyPosition = "PREFIX", _CurrencySymbol & " ", "" ) &
		        FormatString.Component.MakeStringSafe( custom_prefix )

		    VAR _Suffix =
		        IF ( _CurrencyPosition = "SUFFIX", " " & _CurrencySymbol, "" ) &
		        FormatString.Component.MakeStringSafe( custom_suffix )

		    VAR _FormatString =
		        _Prefix & _NumberFormat & _Suffix

		    RETURN
		        _FormatString
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.DynamicCurrency' = ```

		// Get currency format string based on currency code
		// Returns appropriate number format with currency symbol placement
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    // Expects a column reference used for selecting a currency in the report, like 'Exchange Rate'[Currency Code]
		    currency_code: ANYREF,

		    // Base format string
		    // Recommended: "#,##0"
		    decimal_places: INT64
		)
		=>
		    VAR _BaseFormat =
		        FormatString.Component.DecimalPlaces( "#,##0", decimal_places )

		    VAR _CurrencyPosition =
		        FormatString.Component.GetCurrencyPosition ( currency_code )

		    VAR _CurrencySymbol =
		        FormatString.Component.GetCurrencySymbol ( currency_code )

		    VAR _Prefix =
		        IF ( _CurrencyPosition = "PREFIX", _CurrencySymbol & " ", "" )

		    VAR _Suffix =
		        IF ( _CurrencyPosition = "SUFFIX", " " & _CurrencySymbol, "" )

		    VAR _Format =
		        _Prefix & _BaseFormat & _Suffix

		    RETURN
		        _Format
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.Symbols' = ```

		// Get comparison symbol based on style and value sign
		// Returns appropriate symbol for positive, negative, or zero values
		(
		    // Symbol style - number (1-9) or text:
		    // 1 or "ARROWS": ‚Üë/‚Üì
		    // 2 or "TRIANGLES": ‚ñ≤/‚ñº
		    // 3 or "PLUSMINUS": +/-
		    // 4 or "CHEVRONS": ÀÑ/ÀÖ
		    // 5 or "GREENRED": üü¢/üî¥
		    // 6 or "BLUEORANGE": üîµ/üü†
		    // 7 or "BLOCKARROWS": ‚¨Ü/‚¨á
		    // 8 or "CHECKCROSS": ‚úì/‚úó
		    // 9 or "NONE": no symbol
		    symbol_style: ANYVAL,

		    // Value type: "POSITIVE", "NEGATIVE", or "ZERO"
		    value_type: STRING
		)
		=>
		    VAR _SymbolCode =
		        IF ( ISNUMBER ( symbol_style ),
		            symbol_style,
		            SWITCH ( UPPER ( symbol_style ),
		                "ARROWS", 1,
		                "TRIANGLES", 2,
		                "PLUSMINUS", 3,
		                "CHEVRONS", 4,
		                "GREENRED", 5,
		                "BLUEORANGE", 6,
		                "BLOCKARROWS", 7,
		                "CHECKCROSS", 8,
		                "NONE", 9,
		                9
		            )
		        )

		    VAR _Symbol =
		        SWITCH ( value_type,
		            "POSITIVE",
		                SWITCH ( _SymbolCode,
		                    1, "‚Üë",
		                    2, "‚ñ≤",
		                    3, "+",
		                    4, "ÀÑ",
		                    5, "üü¢",
		                    6, "üîµ",
		                    7, "‚¨Ü",
		                    8, "‚úì",
		                    9, "",
		                    ""
		                ),
		            "NEGATIVE",
		                SWITCH ( _SymbolCode,
		                    1, "‚Üì",
		                    2, "‚ñº",
		                    3, "-",
		                    4, "ÀÖ",
		                    5, "üî¥",
		                    6, "üü†",
		                    7, "‚¨á",
		                    8, "‚úó",
		                    9, "",
		                    ""
		                ),
		            ""
		        )

		    RETURN
		        _Symbol
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.MakeStringSafe' = 

		// Wraps strings in double-quotes to avoid issues with format string interpretation
		(
		    // The value you want to put in the format string
		    unsafe_string : STRING
		)
		=>
		    """" & unsafe_string & """"

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.GetCurrencySymbol' = ```

		// Get currency symbol based on currency code
		// Returns currency symbol as a string (e.g., "$" or "‚Ç¨")
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )

		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )

		    VAR _Symbol =
		        SELECTCOLUMNS ( _Currency, ''[Currency Symbol] )

		    RETURN
		        _Symbol
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.GetCurrencyPosition' = ```

		// Get currency position based on currency code
		// Returns either "PREFIX" or "SUFFIX"
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )

		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )

		    VAR _Position =
		        SELECTCOLUMNS ( _Currency, ''[Currency Position] )

		    RETURN
		        _Position
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.GetCurrencyFormat.PNZ' = ```

		// Get currency format based on currency code
		// Returns positive; negative; zero format string (i.e. $#,##0.0; ($-#,##0.0); $0)
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )

		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )

		    VAR _Symbol =
		        SELECTCOLUMNS ( _Currency, ''[Format String PNZ] )

		    RETURN
		        _Symbol
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.GetCurrencyFormat' = ```

		// Get currency format based on currency code
		// Returns simple currency format string (i.e. $#,##0.0)
		(
		    // Currency code (ISO 4217 three-letter code)
		    // Examples: CAD, EUR, GBP, JPY, etc.
		    currency_code: ANYREF
		)
		=>
		    VAR _Code =
		        SELECTEDVALUE ( currency_code )

		    VAR _Currency =
		        FILTER (
		            -- Calc. table with common currencies and formats
		            -- Optionally replace with your own, in-memory exchange rate table
		            FormatString.Component.CurrencyTable(),
		            ''[Currency Code] = _Code
		        )

		    VAR _Symbol =
		        SELECTCOLUMNS ( _Currency, ''[Format String] )

		    RETURN
		        _Symbol
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.DynamicUnits' = ```

		// Helper function to dynamically round and format values
		(
		    // Base format string
		    // Expects a valid format string base, i.e. "#,##0"
		    base_format: STRING,

		    // The value to format
		    format_value: EXPR
		)
		=>
		    VAR _CurrentValue =
		        format_value

		    VAR _Format =
		        base_format &
		        SWITCH (
		            TRUE (),
		            _CurrentValue <= 1E3, ".",
		            _CurrentValue <= 1E4, ",.00 K",
		            _CurrentValue <= 1E5, ",.0 K",
		            _CurrentValue <= 1E6, ",. K",
		            _CurrentValue <= 1E7, ",,.00 M",
		            _CurrentValue <= 1E8, ",,.0 M",
		            _CurrentValue <= 1E9, ",,. M",
		            _CurrentValue <= 1E10, ",,.00 bn",
		            _CurrentValue <= 1E11, ",,.0 bn",
		            _CurrentValue <= 1E12, ",,. bn",
		            _CurrentValue <= 1E13, ",,.00 tn",
		            _CurrentValue <= 1E14, ",,.0 tn",
		            _CurrentValue <= 1E15, ",,. tn"
		        )
		    RETURN
		        _Format
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.DecimalPlaces' = ```

		// Returns a 0 string repeated a number of times equal to the number of decimal places
		(
		    // Base format string
		    // Expects a valid format string base, i.e. "#,##0"
		    base_format: STRING,

		    // Number of decimal places
		    // Expects an integer value from 0-9
		    decimal_places: INT64
		)
		=>
		    base_format
		    &
		    IF (
		        decimal_places > 0,
		        "."
		            & REPT ( "0", MIN ( decimal_places, 9 ) ),
		        ""
		    )
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta

function 'DaxLib.FormatString.Component.CurrencyTable' = ```

		// Get currency reference table with codes, symbols, position, and format strings
		// Returns table with currency metadata for use in other calculations
		// Mainly serves as an example of a function that takes no arguments and returns a table, but also useful if you don't have a currency table with symbols, positions, and formats
		()
		=>
		    VAR _CurrencyTable =
		        DATATABLE (
		            "Currency Code", STRING,
		            "Currency Symbol", STRING,
		            "Currency Position", STRING,
		            "Format String", STRING,
		            "Format String PNZ", STRING,
		            {
		                -- Major currencies
		                { "CAD", "C$", "PREFIX", "C$#,##0", "C$#,##0;-C$#,##0;C$0" },
		                { "EUR", "‚Ç¨", "SUFFIX", "#,##0 ‚Ç¨", "#,##0 ‚Ç¨;-#,##0 ‚Ç¨;0 ‚Ç¨" },
		                { "GBP", "¬£", "PREFIX", "¬£#,##0", "¬£#,##0;-¬£#,##0;¬£0" },
		                { "JPY", "¬•", "PREFIX", "¬•#,##0", "¬•#,##0;-¬•#,##0;¬•0" },
		                { "CHF", "CHF", "PREFIX", "CHF #,##0", "CHF #,##0;-CHF #,##0;CHF 0" },

		                -- Dollar variants
		                { "USD", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "AUD", "A$", "PREFIX", "A$#,##0", "A$#,##0;-A$#,##0;A$0" },
		                { "NZD", "NZ$", "PREFIX", "NZ$#,##0", "NZ$#,##0;-NZ$#,##0;NZ$0" },
		                { "HKD", "HK$", "PREFIX", "HK$#,##0", "HK$#,##0;-HK$#,##0;HK$0" },
		                { "SGD", "S$", "PREFIX", "S$#,##0", "S$#,##0;-S$#,##0;S$0" },
		                { "TWD", "NT$", "PREFIX", "NT$#,##0", "NT$#,##0;-NT$#,##0;NT$0" },

		                -- Asian currencies
		                { "CNY", "¬•", "PREFIX", "¬•#,##0", "¬•#,##0;-¬•#,##0;¬•0" },
		                { "INR", "‚Çπ", "PREFIX", "‚Çπ#,##0", "‚Çπ#,##0;-‚Çπ#,##0;‚Çπ0" },
		                { "KRW", "‚Ç©", "PREFIX", "‚Ç©#,##0", "‚Ç©#,##0;-‚Ç©#,##0;‚Ç©0" },
		                { "THB", "‡∏ø", "PREFIX", "‡∏ø#,##0", "‡∏ø#,##0;-‡∏ø#,##0;‡∏ø0" },
		                { "PHP", "‚Ç±", "PREFIX", "‚Ç±#,##0", "‚Ç±#,##0;-‚Ç±#,##0;‚Ç±0" },
		                { "IDR", "Rp", "PREFIX", "Rp#,##0", "Rp#,##0;-Rp#,##0;Rp0" },
		                { "MYR", "RM", "PREFIX", "RM#,##0", "RM#,##0;-RM#,##0;RM0" },
		                { "VND", "‚Ç´", "PREFIX", "‚Ç´#,##0", "‚Ç´#,##0;-‚Ç´#,##0;‚Ç´0" },
		                { "PKR", "Rs", "PREFIX", "Rs#,##0", "Rs#,##0;-Rs#,##0;Rs0" },
		                { "BDT", "‡ß≥", "PREFIX", "‡ß≥#,##0", "‡ß≥#,##0;-‡ß≥#,##0;‡ß≥0" },
		                { "LKR", "Rs", "PREFIX", "Rs#,##0", "Rs#,##0;-Rs#,##0;Rs0" },
		                { "RUB", "‚ÇΩ", "PREFIX", "‚ÇΩ#,##0", "‚ÇΩ#,##0;-‚ÇΩ#,##0;‚ÇΩ0" },
		                { "UAH", "‚Ç¥", "PREFIX", "‚Ç¥#,##0", "‚Ç¥#,##0;-‚Ç¥#,##0;‚Ç¥0" },
		                { "KZT", "‚Ç∏", "PREFIX", "‚Ç∏#,##0", "‚Ç∏#,##0;-‚Ç∏#,##0;‚Ç∏0" },
		                { "BYN", "Br", "PREFIX", "Br#,##0", "Br#,##0;-Br#,##0;Br0" },
		                { "UZS", "so ªm", "SUFFIX", "#,##0 so ªm", "#,##0 so ªm;-#,##0 so ªm;0 so ªm" },
		                { "AZN", "‚Çº", "PREFIX", "‚Çº#,##0", "‚Çº#,##0;-‚Çº#,##0;‚Çº0" },
		                { "GEL", "‚Çæ", "PREFIX", "‚Çæ#,##0", "‚Çæ#,##0;-‚Çæ#,##0;‚Çæ0" },
		                { "AMD", "÷è", "PREFIX", "÷è#,##0", "÷è#,##0;-÷è#,##0;÷è0" },

		                -- European currencies
		                { "SEK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },
		                { "NOK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },
		                { "DKK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },
		                { "PLN", "z≈Ç", "SUFFIX", "#,##0 z≈Ç", "#,##0 z≈Ç;-#,##0 z≈Ç;0 z≈Ç" },
		                { "HUF", "Ft", "SUFFIX", "#,##0 Ft", "#,##0 Ft;-#,##0 Ft;0 Ft" },
		                { "CZK", "Kƒç", "SUFFIX", "#,##0 Kƒç", "#,##0 Kƒç;-#,##0 Kƒç;0 Kƒç" },
		                { "RON", "lei", "SUFFIX", "#,##0 lei", "#,##0 lei;-#,##0 lei;0 lei" },
		                { "BGN", "–ª–≤", "SUFFIX", "#,##0 –ª–≤", "#,##0 –ª–≤;-#,##0 –ª–≤;0 –ª–≤" },
		                { "HRK", "kn", "SUFFIX", "#,##0 kn", "#,##0 kn;-#,##0 kn;0 kn" },
		                { "ISK", "kr", "SUFFIX", "#,##0 kr", "#,##0 kr;-#,##0 kr;0 kr" },

		                -- Latin American
		                { "MXN", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "BRL", "R$", "PREFIX", "R$#,##0", "R$#,##0;-R$#,##0;R$0" },
		                { "CLP", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "COP", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "ARS", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },
		                { "PEN", "S/", "PREFIX", "S/#,##0", "S/#,##0;-S/#,##0;S/0" },
		                { "UYU", "$U", "PREFIX", "$U#,##0", "$U#,##0;-$U#,##0;$U0" },
		                { "BOB", "Bs", "PREFIX", "Bs#,##0", "Bs#,##0;-Bs#,##0;Bs0" },
		                { "PYG", "‚Ç≤", "PREFIX", "‚Ç≤#,##0", "‚Ç≤#,##0;-‚Ç≤#,##0;‚Ç≤0" },
		                { "VES", "Bs", "PREFIX", "Bs#,##0", "Bs#,##0;-Bs#,##0;Bs0" },
		                { "GTQ", "Q", "PREFIX", "Q#,##0", "Q#,##0;-Q#,##0;Q0" },
		                { "CRC", "‚Ç°", "PREFIX", "‚Ç°#,##0", "‚Ç°#,##0;-‚Ç°#,##0;‚Ç°0" },
		                { "DOP", "RD$", "PREFIX", "RD$#,##0", "RD$#,##0;-RD$#,##0;RD$0" },
		                { "CUP", "$", "PREFIX", "$#,##0", "$#,##0;-$#,##0;$0" },

		                -- Middle Eastern & African
		                { "TRY", "‚Ç∫", "PREFIX", "‚Ç∫#,##0", "‚Ç∫#,##0;-‚Ç∫#,##0;‚Ç∫0" },
		                { "ILS", "‚Ç™", "PREFIX", "‚Ç™#,##0", "‚Ç™#,##0;-‚Ç™#,##0;‚Ç™0" },
		                { "AED", "AED", "PREFIX", "AED #,##0", "AED #,##0;-AED #,##0;AED 0" },
		                { "SAR", "SAR", "PREFIX", "SAR #,##0", "SAR #,##0;-SAR #,##0;SAR 0" },
		                { "QAR", "QR", "PREFIX", "QR #,##0", "QR #,##0;-QR #,##0;QR 0" },
		                { "KWD", "KD", "PREFIX", "KD #,##0", "KD #,##0;-KD #,##0;KD 0" },
		                { "BHD", "BD", "PREFIX", "BD #,##0", "BD #,##0;-BD #,##0;BD 0" },
		                { "OMR", "OMR", "PREFIX", "OMR #,##0", "OMR #,##0;-OMR #,##0;OMR 0" },
		                { "JOD", "JD", "PREFIX", "JD #,##0", "JD #,##0;-JD #,##0;JD 0" },
		                { "EGP", "E¬£", "PREFIX", "E¬£#,##0", "E¬£#,##0;-E¬£#,##0;E¬£0" },
		                { "MAD", "MAD", "PREFIX", "MAD #,##0", "MAD #,##0;-MAD #,##0;MAD 0" },
		                { "ZAR", "R", "PREFIX", "R #,##0", "R #,##0;-R #,##0;R 0" },
		                { "NGN", "‚Ç¶", "PREFIX", "‚Ç¶#,##0", "‚Ç¶#,##0;-‚Ç¶#,##0;‚Ç¶0" },
		                { "KES", "KSh", "PREFIX", "KSh#,##0", "KSh#,##0;-KSh#,##0;KSh0" },
		                { "GHS", "GH‚Çµ", "PREFIX", "GH‚Çµ#,##0", "GH‚Çµ#,##0;-GH‚Çµ#,##0;GH‚Çµ0" },
		                { "TND", "DT", "PREFIX", "DT #,##0", "DT #,##0;-DT #,##0;DT 0" },
		                { "ETB", "Br", "PREFIX", "Br#,##0", "Br#,##0;-Br#,##0;Br0" },

		                -- SpaceParts fictional currencies
		                { "ARC", "‚Ç≥", "PREFIX", "‚Ç≥ #,##0", "‚Ç≥ #,##0;-‚Ç≥ #,##0;‚Ç≥ 0" },
		                { "BELT", "‡∏ø", "PREFIX", "‡∏ø #,##0", "‡∏ø #,##0;-‡∏ø #,##0;‡∏ø 0" },
		                { "BLO", "≈Å", "SUFFIX", "#,##0 ≈Å", "#,##0 ≈Å;-#,##0 ≈Å;0 ≈Å" },
		                { "BLT", "‚Ç∫", "PREFIX", "‚Ç∫ #,##0", "‚Ç∫ #,##0;-‚Ç∫ #,##0;‚Ç∫ 0" },
		                { "CAL", "¬¢", "SUFFIX", "#,##0 ¬¢", "#,##0 ¬¢;-#,##0 ¬¢;0 ¬¢" },
		                { "CREDITS", "‚Ç°", "PREFIX", "‚Ç° #,##0", "‚Ç° #,##0;-‚Ç° #,##0;‚Ç° 0" },
		                { "ELD", "Œû", "SUFFIX", "#,##0 Œû", "#,##0 Œû;-#,##0 Œû;0 Œû" },
		                { "HAL", "ƒ¶", "PREFIX", "ƒ¶ #,##0", "ƒ¶ #,##0;-ƒ¶ #,##0;ƒ¶ 0" },
		                { "ILOS", "≈Ç", "SUFFIX", "#,##0 ≈Ç", "#,##0 ≈Ç;-#,##0 ≈Ç;0 ≈Ç" },
		                { "LAK", "‚Ç≠", "PREFIX", "‚Ç≠ #,##0", "‚Ç≠ #,##0;-‚Ç≠ #,##0;‚Ç≠ 0" },
		                { "MCR", "‚Ç•", "PREFIX", "‚Ç• #,##0", "‚Ç• #,##0;-‚Ç• #,##0;‚Ç• 0" },
		                { "OTN", "√ò", "PREFIX", "√ò #,##0", "√ò #,##0;-√ò #,##0;√ò 0" },
		                { "UPN", "…Ñ", "SUFFIX", "#,##0 …Ñ", "#,##0 …Ñ;-#,##0 …Ñ;0 …Ñ" }
		            }
		        )

		    RETURN
		        _CurrencyTable
		```

	annotation DAXLIB_PackageId = DaxLib.FormatString

	annotation DAXLIB_PackageVersion = 1.0.0-beta
